<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>C√°lculo na Ci√™ncia da Computa√ß√£o: Uma Explora√ß√£o Interativa</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Monaco:wght@400;700&family=Hack:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <!-- Tema Hacker GitHub Pages -->
    <style>
      /* Base Hacker Theme Colors */
      :root {
        overflow-y: scroll;
        --hacker-bg: #0d1117;
        --hacker-secondary-bg: #161b22;
        --hacker-border: #21262d;
        --hacker-text: #00ff41;
        --hacker-text-secondary: #7d8590;
        --hacker-accent: #00ff41;
        --hacker-accent-hover: #00cc33;
        --hacker-card-bg: #0d1117;
        --hacker-card-border: #30363d;
      }

      body {
        font-family: "Monaco", "Hack", "Courier New", monospace;
        background-color: var(--hacker-bg);
        color: var(--hacker-text);
        margin: 0;
        padding: 0;
        line-height: 1.6;
        background-image: radial-gradient(
            circle at 20% 50%,
            rgba(0, 255, 65, 0.1) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 20%,
            rgba(0, 255, 65, 0.1) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 40% 80%,
            rgba(0, 255, 65, 0.1) 0%,
            transparent 50%
          );
        height: 100%;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      /* Header Styles */
      header {
        text-align: center;
        margin-bottom: 60px;
        padding: 40px 20px;
        border: 2px solid var(--hacker-accent);
        border-radius: 10px;
        background: linear-gradient(
          135deg,
          rgba(0, 255, 65, 0.1) 0%,
          rgba(13, 17, 23, 0.9) 100%
        );
        box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
      }

      h1 {
        font-size: 3rem;
        margin-bottom: 20px;
        color: var(--hacker-accent);
        text-shadow: 0 0 10px var(--hacker-accent);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      .subtitle {
        font-size: 1.2rem;
        color: var(--hacker-text-secondary);
        max-width: 800px;
        margin: 0 auto 30px;
        line-height: 1.8;
      }

      /* Bot√£o Artigo */
      .article-btn {
        display: inline-block;
        background: linear-gradient(
          45deg,
          var(--hacker-accent),
          var(--hacker-accent-hover)
        );
        color: var(--hacker-bg);
        padding: 15px 30px;
        text-decoration: none;
        border-radius: 8px;
        font-weight: 700;
        font-size: 1.1rem;
        transition: all 0.3s ease;
        border: 2px solid var(--hacker-accent);
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 0 15px rgba(0, 255, 65, 0.5);
      }

      .article-btn:hover {
        background: var(--hacker-bg);
        color: var(--hacker-accent);
        box-shadow: 0 0 25px rgba(0, 255, 65, 0.8);
        transform: translateY(-2px);
      }

      /* Navigation */
      nav {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-bottom: 40px;
        flex-wrap: wrap;
      }

      .nav-button {
        background: var(--hacker-secondary-bg);
        color: var(--hacker-text);
        border: 2px solid var(--hacker-border);
        padding: 12px 24px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: inherit;
        font-size: 1rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .nav-button:hover,
      .nav-button.active {
        background: var(--hacker-accent);
        color: var(--hacker-bg);
        border-color: var(--hacker-accent);
        box-shadow: 0 0 15px rgba(0, 255, 65, 0.5);
        transform: translateY(-2px);
      }

      /* Cards */
      .card {
        background: var(--hacker-card-bg);
        border: 2px solid var(--hacker-card-border);
        border-radius: 10px;
        margin-bottom: 30px;
        overflow: hidden;
        transition: all 0.3s ease;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        position: relative;
      }

      .card:hover {
        border-color: var(--hacker-accent);
        box-shadow: 0 8px 30px rgba(0, 255, 65, 0.3);
        transform: translateY(-5px);
      }

      .card::before {
        content: "Clique para expandir";
        position: absolute;
        top: 5px;
        right: 15px;
        font-size: 0.7rem;
        color: var(--hacker-text-secondary);
        opacity: 0;
        transition: opacity 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        pointer-events: none;
      }

      .card:hover::before {
        opacity: 0.8;
      }

      .card-header {
        padding: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        border-bottom: 1px solid var(--hacker-border);
        position: relative;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .card-header:hover {
        background: rgba(0, 255, 65, 0.05);
      }

      .card-header::after {
        content: "‚ñº";
        color: var(--hacker-accent);
        font-size: 1.2rem;
        transition: transform 0.3s ease;
        margin-left: 15px;
        flex-shrink: 0;
        animation: pulse 2s infinite;
      }

      .card-header.expanded::after {
        transform: rotate(180deg);
        animation: none;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.7;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.1);
        }
      }

      .card-content {
        flex: 1;
      }

      /* Adicionar indica√ß√£o visual de clic√°vel */
      .card-header:hover::after {
        color: var(--hacker-accent-hover);
        text-shadow: 0 0 5px var(--hacker-accent);
        animation: none;
        transform: scale(1.2);
      }

      .card-header.expanded:hover::after {
        transform: rotate(180deg) scale(1.2);
      }

      .card-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--hacker-accent);
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .card-summary {
        color: var(--hacker-text-secondary);
        line-height: 1.6;
      }

      /* Details Content */
      .details-content {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.7s ease-in-out;
        background: var(--hacker-secondary-bg);
        border-top: 1px solid var(--hacker-border);
      }

      .details-content.open {
        max-height: 2000px;
      }

      .details-inner {
        padding: 30px;
      }

      .details-content p {
        margin-bottom: 20px;
        line-height: 1.7;
        color: var(--hacker-text-secondary);
      }

      .details-content ul {
        list-style: none;
        padding-left: 0;
        margin-bottom: 20px;
      }

      .details-content li {
        padding: 8px 0;
        padding-left: 20px;
        position: relative;
        color: var(--hacker-text-secondary);
        line-height: 1.6;
      }

      .details-content li::before {
        content: ">";
        color: var(--hacker-accent);
        font-weight: bold;
        position: absolute;
        left: 0;
      }

      .details-content strong {
        color: var(--hacker-accent);
        font-weight: 700;
      }

      /* Chart Container */
      .chart-container {
        position: relative;
        width: 100%;
        max-width: 600px;
        margin: 30px auto;
        height: 300px;
        background: var(--hacker-bg);
        border: 2px solid var(--hacker-accent);
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
      }

      /* Buttons */
      .action-btn {
        background: var(--hacker-accent);
        color: var(--hacker-bg);
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        cursor: pointer;
        font-family: inherit;
        font-weight: 700;
        font-size: 1rem;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
      }

      .action-btn:hover {
        background: var(--hacker-accent-hover);
        box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
        transform: translateY(-2px);
      }

      /* Sliders */
      .slider-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .slider-group {
        background: var(--hacker-secondary-bg);
        padding: 20px;
        border-radius: 8px;
        border: 1px solid var(--hacker-border);
      }

      .slider-label {
        display: block;
        font-size: 0.9rem;
        font-weight: 700;
        color: var(--hacker-accent);
        margin-bottom: 10px;
        text-transform: uppercase;
      }

      .slider {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: var(--hacker-border);
        outline: none;
        appearance: none;
        cursor: pointer;
      }

      .slider::-webkit-slider-thumb {
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--hacker-accent);
        cursor: pointer;
        box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
      }

      .slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--hacker-accent);
        cursor: pointer;
        border: none;
        box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
      }

      /* Responsive */
      @media (max-width: 768px) {
        h1 {
          font-size: 2rem;
        }

        .container {
          padding: 15px;
        }

        nav {
          flex-direction: column;
          align-items: center;
        }

        .nav-button {
          width: 100%;
          max-width: 300px;
        }

        .slider-container {
          grid-template-columns: 1fr;
        }
      }

      /* Terminal Effect */
      .terminal-effect {
        position: relative;
        overflow: hidden;
      }

      .terminal-effect::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(0, 255, 65, 0.3),
          transparent
        );
        animation: scan 3s infinite;
      }

      @keyframes scan {
        0% {
          left: -100%;
        }
        100% {
          left: 100%;
        }
      }
    </style>
  </head>
  <body class="terminal-effect">
    <div class="container">
      <header>
        <h1>O C√°lculo no Cora√ß√£o da Computa√ß√£o</h1>
        <p class="subtitle">
          Uma explora√ß√£o interativa de como as integrais e derivadas impulsionam
          a tecnologia que usamos todos os dias.
        </p>

        <!-- Bot√£o Artigo na √çntegra -->
        <div>
          <a href="artigo.html" class="article-btn"> üìÑ Artigo na √çntegra </a>
        </div>
      </header>

      <nav>
        <button id="nav-integrals" class="nav-button">
          Aplica√ß√µes de Integrais
        </button>
        <button id="nav-derivatives" class="nav-button">
          Aplica√ß√µes de Derivadas
        </button>
      </nav>

      <main id="content-area"></main>
    </div>

    <script>
      const contentData = {
        integrals: [
          {
            id: "signal",
            title: "Processamento de Sinais e Imagens",
            summary:
              "Integrais s√£o usadas para filtrar ru√≠dos, comprimir dados (JPEG, MP3) e analisar caracter√≠sticas em sinais e imagens atrav√©s de conceitos como a Transformada de Fourier e convolu√ß√£o.",
            details: `
                        <p>No processamento de sinais e imagens, a capacidade de acumular ou transformar dados ao longo do tempo ou espa√ßo √© fundamental. As integrais fornecem a base matem√°tica para isso.</p>
                        <ul>
                            <li><strong>Filtragem de Sinais:</strong> Filtros de m√©dia m√≥vel, uma forma discreta de integra√ß√£o, suavizam dados ruidosos de sensores ou √°udio.</li>
                            <li><strong>Transformadas (Fourier, Laplace):</strong> Definidas por integrais, essas transformadas convertem sinais para o dom√≠nio da frequ√™ncia, permitindo compress√£o de dados (como em MP3 e JPEG) e an√°lise de caracter√≠sticas (reconhecimento de voz).</li>
                            <li><strong>Convolu√ß√£o:</strong> Usada em vis√£o computacional, a convolu√ß√£o (uma integral) aplica filtros para suavizar imagens, detectar bordas e extrair caracter√≠sticas em Redes Neurais Convolucionais.</li>
                        </ul>
                        <p><strong>Exemplo Interativo:</strong> O gr√°fico abaixo mostra um sinal com ru√≠do. Clique no bot√£o para aplicar um filtro de m√©dia m√≥vel (uma aproxima√ß√£o da integra√ß√£o) e veja como o sinal √© suavizado, tornando a tend√™ncia subjacente mais clara.</p>
                        <div class="chart-container">
                            <canvas id="signal-chart"></canvas>
                        </div>
                        <div style="text-align: center;">
                            <button id="toggle-filter-btn" class="action-btn">Aplicar Filtro (Integra√ß√£o)</button>
                        </div>
                    `,
          },
          {
            id: "probability",
            title: "Probabilidade e IA",
            summary:
              'Em Machine Learning, integrais calculam probabilidades para eventos cont√≠nuos (usando Fun√ß√µes de Densidade de Probabilidade - PDFs) e o "valor esperado" de uma decis√£o.',
            details: `
                        <p>A Intelig√™ncia Artificial e o Machine Learning dependem da quantifica√ß√£o da incerteza e da an√°lise de distribui√ß√µes de dados. As integrais s√£o a espinha dorsal desses c√°lculos.</p>
                        <ul>
                            <li><strong>Fun√ß√µes de Densidade de Probabilidade (PDFs):</strong> A probabilidade de uma vari√°vel cont√≠nua (como a altura de uma pessoa) cair em um intervalo √© a √°rea sob a curva da PDF, calculada por uma integral.</li>
                            <li><strong>Valor Esperado:</strong> O valor m√©dio "ponderado" de uma vari√°vel aleat√≥ria cont√≠nua √© calculado com uma integral. Isso √© vital para avaliar riscos e otimizar modelos em √°reas como finan√ßas (detec√ß√£o de fraudes) e ve√≠culos aut√¥nomos.</li>
                        </ul>
                        <p>Por exemplo, um carro aut√¥nomo pode usar o valor esperado para calcular o risco de diferentes trajet√≥rias, integrando as probabilidades de v√°rios resultados (como um pedestre atravessar a rua) para tomar a decis√£o mais segura.</p>
                        <div class="chart-container">
                            <canvas id="probability-chart"></canvas>
                        </div>
                    `,
          },
          {
            id: "graphics",
            title: "Computa√ß√£o Gr√°fica e Simula√ß√µes",
            summary:
              "Integrais calculam volumes de objetos 3D e, mais importante, simulam como a luz interage em uma cena para criar imagens realistas atrav√©s do Ray Tracing.",
            details: `
                        <p>Para criar mundos virtuais realistas, os computadores precisam simular a f√≠sica do mundo real. As integrais s√£o essenciais para modelar a geometria e a intera√ß√£o da luz.</p>
                        <ul>
                            <li><strong>C√°lculo de Volume e Massa:</strong> Em softwares de modelagem 3D (CAD) e jogos, o volume de objetos complexos √© calculado por integra√ß√£o, o que √© crucial para simular a f√≠sica (massa, in√©rcia).</li>
                            <li><strong>Renderiza√ß√£o e Ilumina√ß√£o (Ray Tracing):</strong> A cria√ß√£o de imagens fotorrealistas envolve resolver a "Equa√ß√£o de Renderiza√ß√£o", uma equa√ß√£o integral complexa que descreve como a luz se espalha e reflete em uma cena. M√©todos como a "Integra√ß√£o Monte Carlo" s√£o usados para aproximar a solu√ß√£o, tra√ßando caminhos de luz aleat√≥rios para calcular a ilumina√ß√£o, sombras e reflexos.</li>
                        </ul>
                        <p>Cada pixel em um filme de anima√ß√£o moderno √© o resultado de resolver massivamente essas integrais para simular a luz com precis√£o, criando o visual realista que vemos na tela.</p>
                        <div class="chart-container">
                            <canvas id="graphics-chart"></canvas>
                        </div>
                    `,
          },
        ],
        derivatives: [
          {
            id: "ai",
            title: "Intelig√™ncia Artificial e Machine Learning",
            summary:
              "O treinamento de redes neurais √© um processo de otimiza√ß√£o impulsionado por derivadas. O algoritmo de Descida do Gradiente usa derivadas para minimizar o erro do modelo.",
            details: `
                        <p>As derivadas s√£o o motor da otimiza√ß√£o em Machine Learning. A capacidade de um modelo "aprender" a partir dos dados depende fundamentalmente do c√°lculo de taxas de varia√ß√£o.</p>
                        <ul>
                            <li><strong>Descida do Gradiente:</strong> √â o principal algoritmo de otimiza√ß√£o. Ele calcula a derivada (o gradiente) da fun√ß√£o de erro do modelo para determinar a "dire√ß√£o" em que os par√¢metros do modelo devem ser ajustados para reduzir o erro.</li>
                            <li><strong>Backpropagation:</strong> Em redes neurais, a Regra da Cadeia (uma regra de deriva√ß√£o) √© usada para calcular eficientemente os gradientes de todos os pesos na rede, permitindo que o erro seja propagado "para tr√°s" e os pesos sejam atualizados.</li>
                        </ul>
                        <p><strong>Exemplo Interativo:</strong> O gr√°fico abaixo mostra uma fun√ß√£o de custo que queremos minimizar. Clique no bot√£o para iniciar a anima√ß√£o da Descida do Gradiente. O ponto representa nosso modelo, e ele dar√° "passos" na dire√ß√£o oposta ao gradiente (a inclina√ß√£o da curva, dada pela derivada) at√© encontrar o ponto mais baixo (erro m√≠nimo).</p>
                         <div class="chart-container">
                            <canvas id="ai-chart"></canvas>
                        </div>
                        <div style="text-center">
                            <button id="start-gradient-btn" class="action-btn">Iniciar Anima√ß√£o</button>
                        </div>
                    `,
          },
          {
            id: "robotics",
            title: "Rob√≥tica e Sistemas de Controle",
            summary:
              "Controladores PID, que s√£o fundamentais em rob√≥tica, usam termos Proporcional (presente), Integral (passado) e Derivativo (futuro) para controlar movimentos com precis√£o.",
            details: `
                        <p>Para que um rob√¥ (como um drone ou um bra√ßo mec√¢nico) se mova de forma est√°vel e precisa, ele precisa de um sistema de controle. O controlador PID (Proporcional-Integral-Derivativo) √© um dos mais comuns e depende diretamente de conceitos de c√°lculo.</p>
                        <ul>
                            <li><strong>Termo Proporcional (P):</strong> Reage ao erro atual.</li>
                            <li><strong>Termo Integral (I):</strong> Acumula erros passados para eliminar desvios persistentes. Usa o conceito de <strong>integra√ß√£o</strong>.</li>
                            <li><strong>Termo Derivativo (D):</strong> Antecipa o erro futuro observando sua taxa de varia√ß√£o. Usa o conceito de <strong>deriva√ß√£o</strong> para evitar oscila√ß√µes e "frear" o sistema.</li>
                        </ul>
                        <p><strong>Exemplo Interativo:</strong> O gr√°fico mostra um sistema tentando atingir um valor alvo (Setpoint). Ajuste os ganhos Proporcional (P), Integral (I) e Derivativo (D) com os sliders e veja como a resposta do sistema muda. Tente encontrar uma combina√ß√£o que atinja o alvo rapidamente, com pouca oscila√ß√£o (overshoot).</p>
                        <div class="chart-container">
                            <canvas id="robotics-chart"></canvas>
                        </div>
                        <div class="slider-container">
                            <div class="slider-group">
                                <label for="p-slider" class="slider-label">Ganho Proporcional (P): <span id="p-value">0.3</span></label>
                                <input id="p-slider" type="range" min="0" max="1" step="0.01" value="0.3" class="slider">
                            </div>
                            <div class="slider-group">
                                <label for="i-slider" class="slider-label">Ganho Integral (I): <span id="i-value">0.02</span></label>
                                <input id="i-slider" type="range" min="0" max="0.1" step="0.001" value="0.02" class="slider">
                            </div>
                            <div class="slider-group">
                                <label for="d-slider" class="slider-label">Ganho Derivativo (D): <span id="d-value">0.4</span></label>
                                <input id="d-slider" type="range" min="0" max="2" step="0.01" value="0.4" class="slider">
                            </div>
                        </div>
                    `,
          },
          {
            id: "animation",
            title: "Computa√ß√£o Gr√°fica e Anima√ß√£o",
            summary:
              "Derivadas s√£o a base da simula√ß√£o de f√≠sica em jogos e anima√ß√µes, definindo velocidade (derivada da posi√ß√£o) e acelera√ß√£o (derivada da velocidade) para criar movimentos realistas.",
            details: `
                        <p>Em gr√°ficos computacionais, as derivadas s√£o indispens√°veis para simular movimento e para renderizar superf√≠cies de forma realista.</p>
                        <ul>
                            <li><strong>Anima√ß√£o e F√≠sica:</strong> Para animar um personagem ou simular um objeto em um motor de jogo, o sistema precisa saber sua velocidade (a primeira derivada da posi√ß√£o em rela√ß√£o ao tempo) e sua acelera√ß√£o (a segunda derivada). Isso permite a simula√ß√£o de gravidade, colis√µes e outras for√ßas.</li>
                            <li><strong>C√°lculo de Normais:</strong> Para que um objeto 3D seja iluminado corretamente, o computador precisa saber a orienta√ß√£o de sua superf√≠cie em cada ponto. Isso √© feito calculando o "vetor normal" (um vetor perpendicular √† superf√≠cie), que √© obtido atrav√©s das derivadas da fun√ß√£o que descreve a superf√≠cie.</li>
                            <li><strong>Detec√ß√£o de Bordas:</strong> Em processamento de imagens, filtros como o de Sobel usam derivadas para encontrar √°reas de alta varia√ß√£o de cor, que correspondem a bordas em uma imagem.</li>
                        </ul>
                        <p><strong>Exemplo Interativo:</strong> O gr√°fico abaixo ilustra a posi√ß√£o, velocidade e acelera√ß√£o de um objeto em movimento, demonstrando como as derivadas (velocidade = derivada da posi√ß√£o, acelera√ß√£o = derivada da velocidade) descrevem a din√¢mica de um sistema. Pense em um objeto oscilando, por exemplo.</p>
                        <div class="chart-container">
                            <canvas id="animation-chart"></canvas>
                        </div>
                    `,
          },
        ],
      };

      const contentArea = document.getElementById("content-area");
      const navIntegrals = document.getElementById("nav-integrals");
      const navDerivatives = document.getElementById("nav-derivatives");

      let activeCharts = {};

      function destroyChart(id) {
        if (activeCharts[id]) {
          activeCharts[id].destroy();
          delete activeCharts[id];
        }
      }

      function destroyAllCharts() {
        Object.keys(activeCharts).forEach((id) => {
          destroyChart(id);
        });
      }

      function createCard(item) {
        const card = document.createElement("div");
        card.className = "card";
        card.innerHTML = `
                <div class="card-header">
                    <div class="card-content">
                        <h3 class="card-title">${item.title}</h3>
                        <p class="card-summary">${item.summary}</p>
                    </div>
                </div>
                <div id="details-${item.id}" class="details-content">
                    <div class="details-inner">
                        ${item.details}
                    </div>
                </div>
            `;

        const header = card.querySelector(".card-header");
        const details = card.querySelector(".details-content");

        header.addEventListener("click", () => {
          const wasOpen = details.classList.contains("open");

          // Close all other open details
          document
            .querySelectorAll(".details-content.open")
            .forEach((openDetail) => {
              openDetail.classList.remove("open");
            });

          // Remove expanded class from all headers
          document
            .querySelectorAll(".card-header.expanded")
            .forEach((expandedHeader) => {
              expandedHeader.classList.remove("expanded");
            });

          destroyAllCharts();

          if (!wasOpen) {
            details.classList.add("open");
            header.classList.add("expanded");

            // Add a listener to ensure the chart is initialized only after the transition ends
            const onTransitionEnd = (event) => {
              // Check if the transition is for max-height to avoid triggering on other property transitions
              if (event.propertyName === "max-height") {
                initializeChart(item.id);
                // Remove the event listener after it fires once to prevent multiple calls
                details.removeEventListener("transitionend", onTransitionEnd);
              }
            };
            details.addEventListener("transitionend", onTransitionEnd);

            // Fallback for cases where transition might not fire or is too quick for Chart.js
            setTimeout(() => {
              if (!activeCharts[item.id]) {
                // Only initialize if not already initialized by transitionend
                initializeChart(item.id);
                details.removeEventListener("transitionend", onTransitionEnd); // Ensure listener is removed
              }
            }, 750); // Slightly longer than the CSS transition duration
          }
        });

        return card;
      }

      function renderContent(category) {
        destroyAllCharts();
        contentArea.innerHTML = "";
        const items = contentData[category];
        items.forEach((item) => {
          contentArea.appendChild(createCard(item));
        });
      }

      function initializeChart(id) {
        destroyChart(id);
        // Ensure the canvas element exists in the DOM before attempting to get its context
        const canvasElement = document.getElementById(`${id}-chart`);
        if (!canvasElement) {
          console.error(`Canvas element with ID '${id}-chart' not found.`);
          return;
        }

        switch (id) {
          case "signal":
            createSignalChart();
            break;
          case "ai":
            createAiChart();
            break;
          case "robotics":
            createRoboticsChart();
            break;
          case "animation":
            createAnimationChart();
            break;
          case "graphics":
            createGraphicsChart();
            break;
          case "probability":
            createProbabilityChart();
            break; // Added this line
        }
      }

      navIntegrals.addEventListener("click", () => {
        renderContent("integrals");
        navIntegrals.classList.add("active");
        navDerivatives.classList.remove("active");
      });

      navDerivatives.addEventListener("click", () => {
        renderContent("derivatives");
        navDerivatives.classList.add("active");
        navIntegrals.classList.remove("active");
      });

      renderContent("integrals");
      navIntegrals.classList.add("active");

      function createSignalChart() {
        const ctx = document.getElementById("signal-chart").getContext("2d");
        const labels = Array.from({ length: 50 }, (_, i) => i + 1);
        const noisyData = labels.map(
          (x) => Math.sin(x / 5) * 10 + (Math.random() - 0.5) * 5
        );

        function movingAverage(data, windowSize) {
          let result = [];
          for (let i = 0; i < data.length; i++) {
            let start = Math.max(0, i - Math.floor(windowSize / 2));
            let end = Math.min(data.length, i + Math.ceil(windowSize / 2));
            let sum = 0;
            for (let j = start; j < end; j++) {
              sum += data[j];
            }
            result.push(sum / (end - start));
          }
          return result;
        }

        const filteredData = movingAverage(noisyData, 5);

        const chartConfig = {
          type: "line",
          data: {
            labels: labels,
            datasets: [
              {
                label: "Sinal com Ru√≠do",
                data: noisyData,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.1,
                pointRadius: 0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: { y: { beginAtZero: false } },
            plugins: { legend: { position: "top" } },
          },
        };

        activeCharts["signal"] = new Chart(ctx, chartConfig);

        let isFiltered = false;
        // Ensure the event listener is re-attached every time the chart is created/re-created
        document.getElementById("toggle-filter-btn").onclick = () => {
          // Use onclick to easily overwrite previous listeners
          isFiltered = !isFiltered;
          const chart = activeCharts["signal"];
          if (isFiltered) {
            chart.data.datasets.push({
              label: "Sinal Filtrado (Suavizado)",
              data: filteredData,
              borderColor: "#00cc33",
              backgroundColor: "rgba(0, 204, 51, 0.2)",
              tension: 0.4,
              pointRadius: 0,
            });
            document.getElementById("toggle-filter-btn").textContent =
              "Remover Filtro";
          } else {
            chart.data.datasets.pop();
            document.getElementById("toggle-filter-btn").textContent =
              "Aplicar Filtro (Integra√ß√£o)";
          }
          chart.update();
        };
      }

      function createAiChart() {
        const ctx = document.getElementById("ai-chart").getContext("2d");

        const costFunction = (x) => (x - 5) ** 2 + 3;
        const labels = Array.from({ length: 11 }, (_, i) => i);
        const costData = labels.map(costFunction);

        const chartConfig = {
          type: "line",
          data: {
            labels: labels,
            datasets: [
              {
                label: "Fun√ß√£o de Custo",
                data: costData,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
              {
                label: "Posi√ß√£o Atual",
                data: [],
                borderColor: "#ff0040",
                backgroundColor: "#ff0040",
                pointRadius: 8,
                showLine: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { type: "linear", position: "bottom" },
              y: { beginAtZero: false },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
            elements: {
              line: {
                borderColor: "#00ff41",
              },
              point: {
                backgroundColor: "#00ff41",
              },
            },
          },
        };

        activeCharts["ai"] = new Chart(ctx, chartConfig);

        let animationInterval;
        // Ensure the event listener is re-attached every time the chart is created/re-created
        document.getElementById("start-gradient-btn").onclick = () => {
          // Use onclick to easily overwrite previous listeners
          clearInterval(animationInterval);
          let currentX = 0.5;
          const learningRate = 0.2;
          const costDerivative = (x) => 2 * (x - 5);

          const chart = activeCharts["ai"];
          chart.data.datasets[1].data = [
            { x: currentX, y: costFunction(currentX) },
          ];
          chart.update();

          animationInterval = setInterval(() => {
            const gradient = costDerivative(currentX);
            currentX = currentX - learningRate * gradient;

            // Update the point position
            chart.data.datasets[1].data = [
              { x: currentX, y: costFunction(currentX) },
            ];
            chart.update();

            // Stop when close to minimum
            if (Math.abs(currentX - 5) < 0.1) {
              clearInterval(animationInterval);
            }
          }, 300);
        };
      }

      function createRoboticsChart() {
        const pSlider = document.getElementById("p-slider");
        const iSlider = document.getElementById("i-slider");
        const dSlider = document.getElementById("d-slider");

        const pValueSpan = document.getElementById("p-value");
        const iValueSpan = document.getElementById("i-value");
        const dValueSpan = document.getElementById("d-value");

        const ctx = document.getElementById("robotics-chart").getContext("2d");

        function pidController(
          setpoint,
          currentValue,
          error,
          integral,
          derivative,
          dt,
          kp,
          ki,
          kd
        ) {
          const newError = setpoint - currentValue;
          integral += newError * dt;
          derivative = (newError - error) / dt;

          const output = kp * newError + ki * integral + kd * derivative;
          return { output, newError, integral, derivative };
        }

        function simulateSystem(kp, ki, kd) {
          const setpoint = 10;
          let currentValue = 0;
          let error = 0;
          let integral = 0;
          let derivative = 0;
          const dt = 0.1;
          const timeSteps = 100;

          const data = [];
          const labels = [];

          for (let i = 0; i < timeSteps; i++) {
            const time = i * dt;
            const result = pidController(
              setpoint,
              currentValue,
              error,
              integral,
              derivative,
              dt,
              kp,
              ki,
              kd
            );

            // Simple first-order system response
            currentValue += result.output * dt * 0.1;
            error = result.newError;
            integral = result.integral;
            derivative = result.derivative;

            data.push(currentValue);
            labels.push(time.toFixed(1));
          }

          return { data, labels, setpoint };
        }

        function updateChart() {
          const kp = parseFloat(pSlider.value);
          const ki = parseFloat(iSlider.value);
          const kd = parseFloat(dSlider.value);

          pValueSpan.textContent = kp.toFixed(2);
          iValueSpan.textContent = ki.toFixed(3);
          dValueSpan.textContent = kd.toFixed(2);

          const simulation = simulateSystem(kp, ki, kd);

          const chart = activeCharts["robotics"];
          if (chart) {
            chart.data.labels = simulation.labels;
            chart.data.datasets[0].data = simulation.data;
            chart.data.datasets[1].data = Array(simulation.data.length).fill(
              simulation.setpoint
            );
            chart.update();
          }
        }

        const simulation = simulateSystem(0.3, 0.02, 0.4);

        const chartConfig = {
          type: "line",
          data: {
            labels: simulation.labels,
            datasets: [
              {
                label: "Resposta do Sistema",
                data: simulation.data,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.3,
                pointRadius: 0,
              },
              {
                label: "Setpoint (Alvo)",
                data: Array(simulation.data.length).fill(simulation.setpoint),
                borderColor: "#ff0040",
                backgroundColor: "rgba(255, 0, 64, 0.2)",
                borderDash: [5, 5],
                pointRadius: 0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: false,
                title: { display: true, text: "Valor", color: "#00ff41" },
              },
              x: {
                title: { display: true, text: "Tempo (s)", color: "#00ff41" },
              },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
          },
        };

        activeCharts["robotics"] = new Chart(ctx, chartConfig);

        // Add event listeners for sliders
        pSlider.addEventListener("input", updateChart);
        iSlider.addEventListener("input", updateChart);
        dSlider.addEventListener("input", updateChart);
      }

      function createAnimationChart() {
        const ctx = document.getElementById("animation-chart").getContext("2d");

        const time = Array.from({ length: 100 }, (_, i) => i * 0.1);
        const position = time.map((t) => 5 * Math.sin(t) + 5);
        const velocity = time.map((t) => 5 * Math.cos(t));
        const acceleration = time.map((t) => -5 * Math.sin(t));

        const chartConfig = {
          type: "line",
          data: {
            labels: time.map((t) => t.toFixed(1)),
            datasets: [
              {
                label: "Posi√ß√£o",
                data: position,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
              {
                label: "Velocidade (1¬™ Derivada)",
                data: velocity,
                borderColor: "#00cc33",
                backgroundColor: "rgba(0, 204, 51, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
              {
                label: "Acelera√ß√£o (2¬™ Derivada)",
                data: acceleration,
                borderColor: "#ff0040",
                backgroundColor: "rgba(255, 0, 64, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: { title: { display: true, text: "Valor", color: "#00ff41" } },
              x: {
                title: { display: true, text: "Tempo (s)", color: "#00ff41" },
              },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
          },
        };

        activeCharts["animation"] = new Chart(ctx, chartConfig);
      }

      function createGraphicsChart() {
        const ctx = document.getElementById("graphics-chart").getContext("2d");

        // Simulating ray tracing samples for Monte Carlo integration
        const samples = Array.from({ length: 50 }, (_, i) => i + 1);
        const lightIntensity = samples.map((n) => {
          // Simulating convergence of Monte Carlo integration
          const convergence =
            10 * (1 - Math.exp(-n / 10)) + Math.random() * 2 - 1;
          return Math.max(0, convergence);
        });

        const chartConfig = {
          type: "line",
          data: {
            labels: samples,
            datasets: [
              {
                label: "Converg√™ncia da Ilumina√ß√£o (Monte Carlo)",
                data: lightIntensity,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.3,
                pointRadius: 2,
                pointBackgroundColor: "#00ff41",
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                title: {
                  display: true,
                  text: "Intensidade da Luz",
                  color: "#00ff41",
                },
                beginAtZero: true,
              },
              x: {
                title: {
                  display: true,
                  text: "N√∫mero de Amostras Ray Tracing",
                  color: "#00ff41",
                },
              },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
          },
        };

        activeCharts["graphics"] = new Chart(ctx, chartConfig);
      }

      // Fixed and unified functions with Hacker theme colors
      function createAnimationChart() {
        const ctx = document.getElementById("animation-chart").getContext("2d");

        const time = Array.from({ length: 100 }, (_, i) => i * 0.1);
        const position = time.map((t) => 5 * Math.sin(t) + 5);
        const velocity = time.map((t) => 5 * Math.cos(t));
        const acceleration = time.map((t) => -5 * Math.sin(t));

        const chartConfig = {
          type: "line",
          data: {
            labels: time.map((t) => t.toFixed(1)),
            datasets: [
              {
                label: "Posi√ß√£o",
                data: position,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
              {
                label: "Velocidade (1¬™ Derivada)",
                data: velocity,
                borderColor: "#00cc33",
                backgroundColor: "rgba(0, 204, 51, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
              {
                label: "Acelera√ß√£o (2¬™ Derivada)",
                data: acceleration,
                borderColor: "#ff0040",
                backgroundColor: "rgba(255, 0, 64, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                title: { display: true, text: "Valor", color: "#00ff41" },
                grid: { color: "rgba(0, 255, 65, 0.1)" },
                ticks: { color: "#00ff41" },
              },
              x: {
                title: { display: true, text: "Tempo (s)", color: "#00ff41" },
                grid: { color: "rgba(0, 255, 65, 0.1)" },
                ticks: { color: "#00ff41" },
              },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
          },
        };

        activeCharts["animation"] = new Chart(ctx, chartConfig);
      }

      function createGraphicsChart() {
        const ctx = document.getElementById("graphics-chart").getContext("2d");

        // Simulating ray tracing samples for Monte Carlo integration
        const samples = Array.from({ length: 50 }, (_, i) => i + 1);
        const lightIntensity = samples.map((n) => {
          // Simulating convergence of Monte Carlo integration
          const convergence =
            10 * (1 - Math.exp(-n / 10)) + Math.random() * 2 - 1;
          return Math.max(0, convergence);
        });

        const chartConfig = {
          type: "line",
          data: {
            labels: samples,
            datasets: [
              {
                label: "Converg√™ncia da Ilumina√ß√£o (Monte Carlo)",
                data: lightIntensity,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.3,
                pointRadius: 2,
                pointBackgroundColor: "#00ff41",
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                title: {
                  display: true,
                  text: "Intensidade da Luz",
                  color: "#00ff41",
                },
                beginAtZero: true,
                grid: { color: "rgba(0, 255, 65, 0.1)" },
                ticks: { color: "#00ff41" },
              },
              x: {
                title: {
                  display: true,
                  text: "N√∫mero de Amostras Ray Tracing",
                  color: "#00ff41",
                },
                grid: { color: "rgba(0, 255, 65, 0.1)" },
                ticks: { color: "#00ff41" },
              },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
          },
        };

        activeCharts["graphics"] = new Chart(ctx, chartConfig);
      }

      function createProbabilityChart() {
        const ctx = document
          .getElementById("probability-chart")
          .getContext("2d");

        // Normal distribution data
        const x = Array.from({ length: 100 }, (_, i) => (i - 50) / 10);
        const mean = 0;
        const stdDev = 1;
        const pdf = x.map((val) => {
          const exponent = -0.5 * Math.pow((val - mean) / stdDev, 2);
          return (1 / (stdDev * Math.sqrt(2 * Math.PI))) * Math.exp(exponent);
        });

        const chartConfig = {
          type: "line",
          data: {
            labels: x.map((val) => val.toFixed(1)),
            datasets: [
              {
                label: "Fun√ß√£o de Densidade de Probabilidade (PDF)",
                data: pdf,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.3)",
                fill: true,
                tension: 0.4,
                pointRadius: 0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                title: {
                  display: true,
                  text: "Densidade de Probabilidade",
                  color: "#00ff41",
                },
                beginAtZero: true,
                grid: { color: "rgba(0, 255, 65, 0.1)" },
                ticks: { color: "#00ff41" },
              },
              x: {
                title: {
                  display: true,
                  text: "Valor da Vari√°vel Aleat√≥ria",
                  color: "#00ff41",
                },
                grid: { color: "rgba(0, 255, 65, 0.1)" },
                ticks: { color: "#00ff41" },
              },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
          },
        };

        activeCharts["probability"] = new Chart(ctx, chartConfig);
      }
    </script>
  </body>
</html>
