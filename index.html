<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cálculo na Ciência da Computação: Uma Exploração Interativa</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Monaco:wght@400;700&family=Hack:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <!-- Tema Hacker GitHub Pages -->
    <style>
      /* Base Hacker Theme Colors */
      :root {
        overflow-y: scroll;
        --hacker-bg: #0d1117;
        --hacker-secondary-bg: #161b22;
        --hacker-border: #21262d;
        --hacker-text: #00ff41;
        --hacker-text-secondary: #7d8590;
        --hacker-accent: #00ff41;
        --hacker-accent-hover: #00cc33;
        --hacker-card-bg: #0d1117;
        --hacker-card-border: #30363d;
      }

      body {
        font-family: "Monaco", "Hack", "Courier New", monospace;
        background-color: var(--hacker-bg);
        color: var(--hacker-text);
        margin: 0;
        padding: 0;
        line-height: 1.6;
        background-image: radial-gradient(
            circle at 20% 50%,
            rgba(0, 255, 65, 0.1) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 20%,
            rgba(0, 255, 65, 0.1) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 40% 80%,
            rgba(0, 255, 65, 0.1) 0%,
            transparent 50%
          );
        height: 100%;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      /* Header Styles */
      header {
        text-align: center;
        margin-bottom: 60px;
        padding: 40px 20px;
        border: 2px solid var(--hacker-accent);
        border-radius: 10px;
        background: linear-gradient(
          135deg,
          rgba(0, 255, 65, 0.1) 0%,
          rgba(13, 17, 23, 0.9) 100%
        );
        box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
      }

      h1 {
        font-size: 3rem;
        margin-bottom: 20px;
        color: var(--hacker-accent);
        text-shadow: 0 0 10px var(--hacker-accent);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      .subtitle {
        font-size: 1.2rem;
        color: var(--hacker-text-secondary);
        max-width: 800px;
        margin: 0 auto 30px;
        line-height: 1.8;
      }

      /* Botão Artigo */
      .article-btn {
        display: inline-block;
        background: linear-gradient(
          45deg,
          var(--hacker-accent),
          var(--hacker-accent-hover)
        );
        color: var(--hacker-bg);
        padding: 15px 30px;
        text-decoration: none;
        border-radius: 8px;
        font-weight: 700;
        font-size: 1.1rem;
        transition: all 0.3s ease;
        border: 2px solid var(--hacker-accent);
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 0 15px rgba(0, 255, 65, 0.5);
      }

      .article-btn:hover {
        background: var(--hacker-bg);
        color: var(--hacker-accent);
        box-shadow: 0 0 25px rgba(0, 255, 65, 0.8);
        transform: translateY(-2px);
      }

      /* Navigation */
      nav {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-bottom: 40px;
        flex-wrap: wrap;
      }

      .nav-button {
        background: var(--hacker-secondary-bg);
        color: var(--hacker-text);
        border: 2px solid var(--hacker-border);
        padding: 12px 24px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: inherit;
        font-size: 1rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .nav-button:hover,
      .nav-button.active {
        background: var(--hacker-accent);
        color: var(--hacker-bg);
        border-color: var(--hacker-accent);
        box-shadow: 0 0 15px rgba(0, 255, 65, 0.5);
        transform: translateY(-2px);
      }

      /* Cards */
      .card {
        background: var(--hacker-card-bg);
        border: 2px solid var(--hacker-card-border);
        border-radius: 10px;
        margin-bottom: 30px;
        overflow: hidden;
        transition: all 0.3s ease;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        position: relative;
      }

      .card:hover {
        border-color: var(--hacker-accent);
        box-shadow: 0 8px 30px rgba(0, 255, 65, 0.3);
        transform: translateY(-5px);
      }

      .card::before {
        content: "Clique para expandir";
        position: absolute;
        top: 5px;
        right: 15px;
        font-size: 0.7rem;
        color: var(--hacker-text-secondary);
        opacity: 0;
        transition: opacity 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        pointer-events: none;
      }

      .card:hover::before {
        opacity: 0.8;
      }

      .card-header {
        padding: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        border-bottom: 1px solid var(--hacker-border);
        position: relative;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .card-header:hover {
        background: rgba(0, 255, 65, 0.05);
      }

      .card-header::after {
        content: "▼";
        color: var(--hacker-accent);
        font-size: 1.2rem;
        transition: transform 0.3s ease;
        margin-left: 15px;
        flex-shrink: 0;
        animation: pulse 2s infinite;
      }

      .card-header.expanded::after {
        transform: rotate(180deg);
        animation: none;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.7;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.1);
        }
      }

      .card-content {
        flex: 1;
      }

      /* Adicionar indicação visual de clicável */
      .card-header:hover::after {
        color: var(--hacker-accent-hover);
        text-shadow: 0 0 5px var(--hacker-accent);
        animation: none;
        transform: scale(1.2);
      }

      .card-header.expanded:hover::after {
        transform: rotate(180deg) scale(1.2);
      }

      .card-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--hacker-accent);
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .card-summary {
        color: var(--hacker-text-secondary);
        line-height: 1.6;
      }

      /* Details Content */
      .details-content {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.7s ease-in-out;
        background: var(--hacker-secondary-bg);
        border-top: 1px solid var(--hacker-border);
      }

      .details-content.open {
        max-height: 2000px;
      }

      .details-inner {
        padding: 30px;
      }

      .details-content p {
        margin-bottom: 20px;
        line-height: 1.7;
        color: var(--hacker-text-secondary);
      }

      .details-content ul {
        list-style: none;
        padding-left: 0;
        margin-bottom: 20px;
      }

      .details-content li {
        padding: 8px 0;
        padding-left: 20px;
        position: relative;
        color: var(--hacker-text-secondary);
        line-height: 1.6;
      }

      .details-content li::before {
        content: ">";
        color: var(--hacker-accent);
        font-weight: bold;
        position: absolute;
        left: 0;
      }

      .details-content strong {
        color: var(--hacker-accent);
        font-weight: 700;
      }

      /* Chart Container */
      .chart-container {
        position: relative;
        width: 100%;
        max-width: 600px;
        margin: 30px auto;
        height: 300px;
        background: var(--hacker-bg);
        border: 2px solid var(--hacker-accent);
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
      }

      /* Buttons */
      .action-btn {
        background: var(--hacker-accent);
        color: var(--hacker-bg);
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        cursor: pointer;
        font-family: inherit;
        font-weight: 700;
        font-size: 1rem;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
      }

      .action-btn:hover {
        background: var(--hacker-accent-hover);
        box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
        transform: translateY(-2px);
      }

      /* Sliders */
      .slider-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .slider-group {
        background: var(--hacker-secondary-bg);
        padding: 20px;
        border-radius: 8px;
        border: 1px solid var(--hacker-border);
      }

      .slider-label {
        display: block;
        font-size: 0.9rem;
        font-weight: 700;
        color: var(--hacker-accent);
        margin-bottom: 10px;
        text-transform: uppercase;
      }

      .slider {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: var(--hacker-border);
        outline: none;
        appearance: none;
        cursor: pointer;
      }

      .slider::-webkit-slider-thumb {
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--hacker-accent);
        cursor: pointer;
        box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
      }

      .slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--hacker-accent);
        cursor: pointer;
        border: none;
        box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
      }

      /* Responsive */
      @media (max-width: 768px) {
        h1 {
          font-size: 2rem;
        }

        .container {
          padding: 15px;
        }

        nav {
          flex-direction: column;
          align-items: center;
        }

        .nav-button {
          width: 100%;
          max-width: 300px;
        }

        .slider-container {
          grid-template-columns: 1fr;
        }
      }

      /* Terminal Effect */
      .terminal-effect {
        position: relative;
        overflow: hidden;
      }

      .terminal-effect::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(0, 255, 65, 0.3),
          transparent
        );
        animation: scan 3s infinite;
      }

      @keyframes scan {
        0% {
          left: -100%;
        }
        100% {
          left: 100%;
        }
      }
    </style>
  </head>
  <body class="terminal-effect">
    <div class="container">
      <header>
        <h1>O Cálculo no Coração da Computação</h1>
        <p class="subtitle">
          Uma exploração interativa de como as integrais e derivadas impulsionam
          a tecnologia que usamos todos os dias.
        </p>

        <!-- Botão Artigo na Íntegra -->
        <div>
          <a href="artigo.html" class="article-btn"> 📄 Artigo na Íntegra </a>
        </div>
      </header>

      <nav>
        <button id="nav-integrals" class="nav-button">
          Aplicações de Integrais
        </button>
        <button id="nav-derivatives" class="nav-button">
          Aplicações de Derivadas
        </button>
      </nav>

      <main id="content-area"></main>
    </div>

    <script>
      const contentData = {
        integrals: [
          {
            id: "signal",
            title: "Processamento de Sinais e Imagens",
            summary:
              "Integrais são usadas para filtrar ruídos, comprimir dados (JPEG, MP3) e analisar características em sinais e imagens através de conceitos como a Transformada de Fourier e convolução.",
            details: `
                        <p>No processamento de sinais e imagens, a capacidade de acumular ou transformar dados ao longo do tempo ou espaço é fundamental. As integrais fornecem a base matemática para isso.</p>
                        <ul>
                            <li><strong>Filtragem de Sinais:</strong> Filtros de média móvel, uma forma discreta de integração, suavizam dados ruidosos de sensores ou áudio.</li>
                            <li><strong>Transformadas (Fourier, Laplace):</strong> Definidas por integrais, essas transformadas convertem sinais para o domínio da frequência, permitindo compressão de dados (como em MP3 e JPEG) e análise de características (reconhecimento de voz).</li>
                            <li><strong>Convolução:</strong> Usada em visão computacional, a convolução (uma integral) aplica filtros para suavizar imagens, detectar bordas e extrair características em Redes Neurais Convolucionais.</li>
                        </ul>
                        <p><strong>Exemplo Interativo:</strong> O gráfico abaixo mostra um sinal com ruído. Clique no botão para aplicar um filtro de média móvel (uma aproximação da integração) e veja como o sinal é suavizado, tornando a tendência subjacente mais clara.</p>
                        <div class="chart-container">
                            <canvas id="signal-chart"></canvas>
                        </div>
                        <div style="text-align: center;">
                            <button id="toggle-filter-btn" class="action-btn">Aplicar Filtro (Integração)</button>
                        </div>
                    `,
          },
          {
            id: "probability",
            title: "Probabilidade e IA",
            summary:
              'Em Machine Learning, integrais calculam probabilidades para eventos contínuos (usando Funções de Densidade de Probabilidade - PDFs) e o "valor esperado" de uma decisão.',
            details: `
                        <p>A Inteligência Artificial e o Machine Learning dependem da quantificação da incerteza e da análise de distribuições de dados. As integrais são a espinha dorsal desses cálculos.</p>
                        <ul>
                            <li><strong>Funções de Densidade de Probabilidade (PDFs):</strong> A probabilidade de uma variável contínua (como a altura de uma pessoa) cair em um intervalo é a área sob a curva da PDF, calculada por uma integral.</li>
                            <li><strong>Valor Esperado:</strong> O valor médio "ponderado" de uma variável aleatória contínua é calculado com uma integral. Isso é vital para avaliar riscos e otimizar modelos em áreas como finanças (detecção de fraudes) e veículos autônomos.</li>
                        </ul>
                        <p>Por exemplo, um carro autônomo pode usar o valor esperado para calcular o risco de diferentes trajetórias, integrando as probabilidades de vários resultados (como um pedestre atravessar a rua) para tomar a decisão mais segura.</p>
                        <div class="chart-container">
                            <canvas id="probability-chart"></canvas>
                        </div>
                    `,
          },
          {
            id: "graphics",
            title: "Computação Gráfica e Simulações",
            summary:
              "Integrais calculam volumes de objetos 3D e, mais importante, simulam como a luz interage em uma cena para criar imagens realistas através do Ray Tracing.",
            details: `
                        <p>Para criar mundos virtuais realistas, os computadores precisam simular a física do mundo real. As integrais são essenciais para modelar a geometria e a interação da luz.</p>
                        <ul>
                            <li><strong>Cálculo de Volume e Massa:</strong> Em softwares de modelagem 3D (CAD) e jogos, o volume de objetos complexos é calculado por integração, o que é crucial para simular a física (massa, inércia).</li>
                            <li><strong>Renderização e Iluminação (Ray Tracing):</strong> A criação de imagens fotorrealistas envolve resolver a "Equação de Renderização", uma equação integral complexa que descreve como a luz se espalha e reflete em uma cena. Métodos como a "Integração Monte Carlo" são usados para aproximar a solução, traçando caminhos de luz aleatórios para calcular a iluminação, sombras e reflexos.</li>
                        </ul>
                        <p>Cada pixel em um filme de animação moderno é o resultado de resolver massivamente essas integrais para simular a luz com precisão, criando o visual realista que vemos na tela.</p>
                        <div class="chart-container">
                            <canvas id="graphics-chart"></canvas>
                        </div>
                    `,
          },
        ],
        derivatives: [
          {
            id: "ai",
            title: "Inteligência Artificial e Machine Learning",
            summary:
              "O treinamento de redes neurais é um processo de otimização impulsionado por derivadas. O algoritmo de Descida do Gradiente usa derivadas para minimizar o erro do modelo.",
            details: `
                        <p>As derivadas são o motor da otimização em Machine Learning. A capacidade de um modelo "aprender" a partir dos dados depende fundamentalmente do cálculo de taxas de variação.</p>
                        <ul>
                            <li><strong>Descida do Gradiente:</strong> É o principal algoritmo de otimização. Ele calcula a derivada (o gradiente) da função de erro do modelo para determinar a "direção" em que os parâmetros do modelo devem ser ajustados para reduzir o erro.</li>
                            <li><strong>Backpropagation:</strong> Em redes neurais, a Regra da Cadeia (uma regra de derivação) é usada para calcular eficientemente os gradientes de todos os pesos na rede, permitindo que o erro seja propagado "para trás" e os pesos sejam atualizados.</li>
                        </ul>
                        <p><strong>Exemplo Interativo:</strong> O gráfico abaixo mostra uma função de custo que queremos minimizar. Clique no botão para iniciar a animação da Descida do Gradiente. O ponto representa nosso modelo, e ele dará "passos" na direção oposta ao gradiente (a inclinação da curva, dada pela derivada) até encontrar o ponto mais baixo (erro mínimo).</p>
                         <div class="chart-container">
                            <canvas id="ai-chart"></canvas>
                        </div>
                        <div style="text-center">
                            <button id="start-gradient-btn" class="action-btn">Iniciar Animação</button>
                        </div>
                    `,
          },
          {
            id: "robotics",
            title: "Robótica e Sistemas de Controle",
            summary:
              "Controladores PID, que são fundamentais em robótica, usam termos Proporcional (presente), Integral (passado) e Derivativo (futuro) para controlar movimentos com precisão.",
            details: `
                        <p>Para que um robô (como um drone ou um braço mecânico) se mova de forma estável e precisa, ele precisa de um sistema de controle. O controlador PID (Proporcional-Integral-Derivativo) é um dos mais comuns e depende diretamente de conceitos de cálculo.</p>
                        <ul>
                            <li><strong>Termo Proporcional (P):</strong> Reage ao erro atual.</li>
                            <li><strong>Termo Integral (I):</strong> Acumula erros passados para eliminar desvios persistentes. Usa o conceito de <strong>integração</strong>.</li>
                            <li><strong>Termo Derivativo (D):</strong> Antecipa o erro futuro observando sua taxa de variação. Usa o conceito de <strong>derivação</strong> para evitar oscilações e "frear" o sistema.</li>
                        </ul>
                        <p><strong>Exemplo Interativo:</strong> O gráfico mostra um sistema tentando atingir um valor alvo (Setpoint). Ajuste os ganhos Proporcional (P), Integral (I) e Derivativo (D) com os sliders e veja como a resposta do sistema muda. Tente encontrar uma combinação que atinja o alvo rapidamente, com pouca oscilação (overshoot).</p>
                        <div class="chart-container">
                            <canvas id="robotics-chart"></canvas>
                        </div>
                        <div class="slider-container">
                            <div class="slider-group">
                                <label for="p-slider" class="slider-label">Ganho Proporcional (P): <span id="p-value">0.3</span></label>
                                <input id="p-slider" type="range" min="0" max="1" step="0.01" value="0.3" class="slider">
                            </div>
                            <div class="slider-group">
                                <label for="i-slider" class="slider-label">Ganho Integral (I): <span id="i-value">0.02</span></label>
                                <input id="i-slider" type="range" min="0" max="0.1" step="0.001" value="0.02" class="slider">
                            </div>
                            <div class="slider-group">
                                <label for="d-slider" class="slider-label">Ganho Derivativo (D): <span id="d-value">0.4</span></label>
                                <input id="d-slider" type="range" min="0" max="2" step="0.01" value="0.4" class="slider">
                            </div>
                        </div>
                    `,
          },
          {
            id: "animation",
            title: "Computação Gráfica e Animação",
            summary:
              "Derivadas são a base da simulação de física em jogos e animações, definindo velocidade (derivada da posição) e aceleração (derivada da velocidade) para criar movimentos realistas.",
            details: `
                        <p>Em gráficos computacionais, as derivadas são indispensáveis para simular movimento e para renderizar superfícies de forma realista.</p>
                        <ul>
                            <li><strong>Animação e Física:</strong> Para animar um personagem ou simular um objeto em um motor de jogo, o sistema precisa saber sua velocidade (a primeira derivada da posição em relação ao tempo) e sua aceleração (a segunda derivada). Isso permite a simulação de gravidade, colisões e outras forças.</li>
                            <li><strong>Cálculo de Normais:</strong> Para que um objeto 3D seja iluminado corretamente, o computador precisa saber a orientação de sua superfície em cada ponto. Isso é feito calculando o "vetor normal" (um vetor perpendicular à superfície), que é obtido através das derivadas da função que descreve a superfície.</li>
                            <li><strong>Detecção de Bordas:</strong> Em processamento de imagens, filtros como o de Sobel usam derivadas para encontrar áreas de alta variação de cor, que correspondem a bordas em uma imagem.</li>
                        </ul>
                        <p><strong>Exemplo Interativo:</strong> O gráfico abaixo ilustra a posição, velocidade e aceleração de um objeto em movimento, demonstrando como as derivadas (velocidade = derivada da posição, aceleração = derivada da velocidade) descrevem a dinâmica de um sistema. Pense em um objeto oscilando, por exemplo.</p>
                        <div class="chart-container">
                            <canvas id="animation-chart"></canvas>
                        </div>
                    `,
          },
        ],
      };

      const contentArea = document.getElementById("content-area");
      const navIntegrals = document.getElementById("nav-integrals");
      const navDerivatives = document.getElementById("nav-derivatives");

      let activeCharts = {};

      function destroyChart(id) {
        if (activeCharts[id]) {
          activeCharts[id].destroy();
          delete activeCharts[id];
        }
      }

      function destroyAllCharts() {
        Object.keys(activeCharts).forEach((id) => {
          destroyChart(id);
        });
      }

      function createCard(item) {
        const card = document.createElement("div");
        card.className = "card";
        card.innerHTML = `
                <div class="card-header">
                    <div class="card-content">
                        <h3 class="card-title">${item.title}</h3>
                        <p class="card-summary">${item.summary}</p>
                    </div>
                </div>
                <div id="details-${item.id}" class="details-content">
                    <div class="details-inner">
                        ${item.details}
                    </div>
                </div>
            `;

        const header = card.querySelector(".card-header");
        const details = card.querySelector(".details-content");

        header.addEventListener("click", () => {
          const wasOpen = details.classList.contains("open");

          // Close all other open details
          document
            .querySelectorAll(".details-content.open")
            .forEach((openDetail) => {
              openDetail.classList.remove("open");
            });

          // Remove expanded class from all headers
          document
            .querySelectorAll(".card-header.expanded")
            .forEach((expandedHeader) => {
              expandedHeader.classList.remove("expanded");
            });

          destroyAllCharts();

          if (!wasOpen) {
            details.classList.add("open");
            header.classList.add("expanded");

            // Add a listener to ensure the chart is initialized only after the transition ends
            const onTransitionEnd = (event) => {
              // Check if the transition is for max-height to avoid triggering on other property transitions
              if (event.propertyName === "max-height") {
                initializeChart(item.id);
                // Remove the event listener after it fires once to prevent multiple calls
                details.removeEventListener("transitionend", onTransitionEnd);
              }
            };
            details.addEventListener("transitionend", onTransitionEnd);

            // Fallback for cases where transition might not fire or is too quick for Chart.js
            setTimeout(() => {
              if (!activeCharts[item.id]) {
                // Only initialize if not already initialized by transitionend
                initializeChart(item.id);
                details.removeEventListener("transitionend", onTransitionEnd); // Ensure listener is removed
              }
            }, 750); // Slightly longer than the CSS transition duration
          }
        });

        return card;
      }

      function renderContent(category) {
        destroyAllCharts();
        contentArea.innerHTML = "";
        const items = contentData[category];
        items.forEach((item) => {
          contentArea.appendChild(createCard(item));
        });
      }

      function initializeChart(id) {
        destroyChart(id);
        // Ensure the canvas element exists in the DOM before attempting to get its context
        const canvasElement = document.getElementById(`${id}-chart`);
        if (!canvasElement) {
          console.error(`Canvas element with ID '${id}-chart' not found.`);
          return;
        }

        switch (id) {
          case "signal":
            createSignalChart();
            break;
          case "ai":
            createAiChart();
            break;
          case "robotics":
            createRoboticsChart();
            break;
          case "animation":
            createAnimationChart();
            break;
          case "graphics":
            createGraphicsChart();
            break;
          case "probability":
            createProbabilityChart();
            break; // Added this line
        }
      }

      navIntegrals.addEventListener("click", () => {
        renderContent("integrals");
        navIntegrals.classList.add("active");
        navDerivatives.classList.remove("active");
      });

      navDerivatives.addEventListener("click", () => {
        renderContent("derivatives");
        navDerivatives.classList.add("active");
        navIntegrals.classList.remove("active");
      });

      renderContent("integrals");
      navIntegrals.classList.add("active");

      function createSignalChart() {
        const ctx = document.getElementById("signal-chart").getContext("2d");
        const labels = Array.from({ length: 50 }, (_, i) => i + 1);
        const noisyData = labels.map(
          (x) => Math.sin(x / 5) * 10 + (Math.random() - 0.5) * 5
        );

        function movingAverage(data, windowSize) {
          let result = [];
          for (let i = 0; i < data.length; i++) {
            let start = Math.max(0, i - Math.floor(windowSize / 2));
            let end = Math.min(data.length, i + Math.ceil(windowSize / 2));
            let sum = 0;
            for (let j = start; j < end; j++) {
              sum += data[j];
            }
            result.push(sum / (end - start));
          }
          return result;
        }

        const filteredData = movingAverage(noisyData, 5);

        const chartConfig = {
          type: "line",
          data: {
            labels: labels,
            datasets: [
              {
                label: "Sinal com Ruído",
                data: noisyData,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.1,
                pointRadius: 0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: { y: { beginAtZero: false } },
            plugins: { legend: { position: "top" } },
          },
        };

        activeCharts["signal"] = new Chart(ctx, chartConfig);

        let isFiltered = false;
        // Ensure the event listener is re-attached every time the chart is created/re-created
        document.getElementById("toggle-filter-btn").onclick = () => {
          // Use onclick to easily overwrite previous listeners
          isFiltered = !isFiltered;
          const chart = activeCharts["signal"];
          if (isFiltered) {
            chart.data.datasets.push({
              label: "Sinal Filtrado (Suavizado)",
              data: filteredData,
              borderColor: "#00cc33",
              backgroundColor: "rgba(0, 204, 51, 0.2)",
              tension: 0.4,
              pointRadius: 0,
            });
            document.getElementById("toggle-filter-btn").textContent =
              "Remover Filtro";
          } else {
            chart.data.datasets.pop();
            document.getElementById("toggle-filter-btn").textContent =
              "Aplicar Filtro (Integração)";
          }
          chart.update();
        };
      }

      function createAiChart() {
        const ctx = document.getElementById("ai-chart").getContext("2d");

        const costFunction = (x) => (x - 5) ** 2 + 3;
        const labels = Array.from({ length: 11 }, (_, i) => i);
        const costData = labels.map(costFunction);

        const chartConfig = {
          type: "line",
          data: {
            labels: labels,
            datasets: [
              {
                label: "Função de Custo",
                data: costData,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
              {
                label: "Posição Atual",
                data: [],
                borderColor: "#ff0040",
                backgroundColor: "#ff0040",
                pointRadius: 8,
                showLine: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { type: "linear", position: "bottom" },
              y: { beginAtZero: false },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
            elements: {
              line: {
                borderColor: "#00ff41",
              },
              point: {
                backgroundColor: "#00ff41",
              },
            },
          },
        };

        activeCharts["ai"] = new Chart(ctx, chartConfig);

        let animationInterval;
        // Ensure the event listener is re-attached every time the chart is created/re-created
        document.getElementById("start-gradient-btn").onclick = () => {
          // Use onclick to easily overwrite previous listeners
          clearInterval(animationInterval);
          let currentX = 0.5;
          const learningRate = 0.2;
          const costDerivative = (x) => 2 * (x - 5);

          const chart = activeCharts["ai"];
          chart.data.datasets[1].data = [
            { x: currentX, y: costFunction(currentX) },
          ];
          chart.update();

          animationInterval = setInterval(() => {
            const gradient = costDerivative(currentX);
            currentX = currentX - learningRate * gradient;

            // Update the point position
            chart.data.datasets[1].data = [
              { x: currentX, y: costFunction(currentX) },
            ];
            chart.update();

            // Stop when close to minimum
            if (Math.abs(currentX - 5) < 0.1) {
              clearInterval(animationInterval);
            }
          }, 300);
        };
      }

      function createRoboticsChart() {
        const pSlider = document.getElementById("p-slider");
        const iSlider = document.getElementById("i-slider");
        const dSlider = document.getElementById("d-slider");

        const pValueSpan = document.getElementById("p-value");
        const iValueSpan = document.getElementById("i-value");
        const dValueSpan = document.getElementById("d-value");

        const ctx = document.getElementById("robotics-chart").getContext("2d");

        function pidController(
          setpoint,
          currentValue,
          error,
          integral,
          derivative,
          dt,
          kp,
          ki,
          kd
        ) {
          const newError = setpoint - currentValue;
          integral += newError * dt;
          derivative = (newError - error) / dt;

          const output = kp * newError + ki * integral + kd * derivative;
          return { output, newError, integral, derivative };
        }

        function simulateSystem(kp, ki, kd) {
          const setpoint = 10;
          let currentValue = 0;
          let error = 0;
          let integral = 0;
          let derivative = 0;
          const dt = 0.1;
          const timeSteps = 100;

          const data = [];
          const labels = [];

          for (let i = 0; i < timeSteps; i++) {
            const time = i * dt;
            const result = pidController(
              setpoint,
              currentValue,
              error,
              integral,
              derivative,
              dt,
              kp,
              ki,
              kd
            );

            // Simple first-order system response
            currentValue += result.output * dt * 0.1;
            error = result.newError;
            integral = result.integral;
            derivative = result.derivative;

            data.push(currentValue);
            labels.push(time.toFixed(1));
          }

          return { data, labels, setpoint };
        }

        function updateChart() {
          const kp = parseFloat(pSlider.value);
          const ki = parseFloat(iSlider.value);
          const kd = parseFloat(dSlider.value);

          pValueSpan.textContent = kp.toFixed(2);
          iValueSpan.textContent = ki.toFixed(3);
          dValueSpan.textContent = kd.toFixed(2);

          const simulation = simulateSystem(kp, ki, kd);

          const chart = activeCharts["robotics"];
          if (chart) {
            chart.data.labels = simulation.labels;
            chart.data.datasets[0].data = simulation.data;
            chart.data.datasets[1].data = Array(simulation.data.length).fill(
              simulation.setpoint
            );
            chart.update();
          }
        }

        const simulation = simulateSystem(0.3, 0.02, 0.4);

        const chartConfig = {
          type: "line",
          data: {
            labels: simulation.labels,
            datasets: [
              {
                label: "Resposta do Sistema",
                data: simulation.data,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.3,
                pointRadius: 0,
              },
              {
                label: "Setpoint (Alvo)",
                data: Array(simulation.data.length).fill(simulation.setpoint),
                borderColor: "#ff0040",
                backgroundColor: "rgba(255, 0, 64, 0.2)",
                borderDash: [5, 5],
                pointRadius: 0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: false,
                title: { display: true, text: "Valor", color: "#00ff41" },
              },
              x: {
                title: { display: true, text: "Tempo (s)", color: "#00ff41" },
              },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
          },
        };

        activeCharts["robotics"] = new Chart(ctx, chartConfig);

        // Add event listeners for sliders
        pSlider.addEventListener("input", updateChart);
        iSlider.addEventListener("input", updateChart);
        dSlider.addEventListener("input", updateChart);
      }

      function createAnimationChart() {
        const ctx = document.getElementById("animation-chart").getContext("2d");

        const time = Array.from({ length: 100 }, (_, i) => i * 0.1);
        const position = time.map((t) => 5 * Math.sin(t) + 5);
        const velocity = time.map((t) => 5 * Math.cos(t));
        const acceleration = time.map((t) => -5 * Math.sin(t));

        const chartConfig = {
          type: "line",
          data: {
            labels: time.map((t) => t.toFixed(1)),
            datasets: [
              {
                label: "Posição",
                data: position,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
              {
                label: "Velocidade (1ª Derivada)",
                data: velocity,
                borderColor: "#00cc33",
                backgroundColor: "rgba(0, 204, 51, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
              {
                label: "Aceleração (2ª Derivada)",
                data: acceleration,
                borderColor: "#ff0040",
                backgroundColor: "rgba(255, 0, 64, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: { title: { display: true, text: "Valor", color: "#00ff41" } },
              x: {
                title: { display: true, text: "Tempo (s)", color: "#00ff41" },
              },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
          },
        };

        activeCharts["animation"] = new Chart(ctx, chartConfig);
      }

      function createGraphicsChart() {
        const ctx = document.getElementById("graphics-chart").getContext("2d");

        // Simulating ray tracing samples for Monte Carlo integration
        const samples = Array.from({ length: 50 }, (_, i) => i + 1);
        const lightIntensity = samples.map((n) => {
          // Simulating convergence of Monte Carlo integration
          const convergence =
            10 * (1 - Math.exp(-n / 10)) + Math.random() * 2 - 1;
          return Math.max(0, convergence);
        });

        const chartConfig = {
          type: "line",
          data: {
            labels: samples,
            datasets: [
              {
                label: "Convergência da Iluminação (Monte Carlo)",
                data: lightIntensity,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.3,
                pointRadius: 2,
                pointBackgroundColor: "#00ff41",
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                title: {
                  display: true,
                  text: "Intensidade da Luz",
                  color: "#00ff41",
                },
                beginAtZero: true,
              },
              x: {
                title: {
                  display: true,
                  text: "Número de Amostras Ray Tracing",
                  color: "#00ff41",
                },
              },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
          },
        };

        activeCharts["graphics"] = new Chart(ctx, chartConfig);
      }

      // Fixed and unified functions with Hacker theme colors
      function createAnimationChart() {
        const ctx = document.getElementById("animation-chart").getContext("2d");

        const time = Array.from({ length: 100 }, (_, i) => i * 0.1);
        const position = time.map((t) => 5 * Math.sin(t) + 5);
        const velocity = time.map((t) => 5 * Math.cos(t));
        const acceleration = time.map((t) => -5 * Math.sin(t));

        const chartConfig = {
          type: "line",
          data: {
            labels: time.map((t) => t.toFixed(1)),
            datasets: [
              {
                label: "Posição",
                data: position,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
              {
                label: "Velocidade (1ª Derivada)",
                data: velocity,
                borderColor: "#00cc33",
                backgroundColor: "rgba(0, 204, 51, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
              {
                label: "Aceleração (2ª Derivada)",
                data: acceleration,
                borderColor: "#ff0040",
                backgroundColor: "rgba(255, 0, 64, 0.2)",
                tension: 0.4,
                pointRadius: 0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                title: { display: true, text: "Valor", color: "#00ff41" },
                grid: { color: "rgba(0, 255, 65, 0.1)" },
                ticks: { color: "#00ff41" },
              },
              x: {
                title: { display: true, text: "Tempo (s)", color: "#00ff41" },
                grid: { color: "rgba(0, 255, 65, 0.1)" },
                ticks: { color: "#00ff41" },
              },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
          },
        };

        activeCharts["animation"] = new Chart(ctx, chartConfig);
      }

      function createGraphicsChart() {
        const ctx = document.getElementById("graphics-chart").getContext("2d");

        // Simulating ray tracing samples for Monte Carlo integration
        const samples = Array.from({ length: 50 }, (_, i) => i + 1);
        const lightIntensity = samples.map((n) => {
          // Simulating convergence of Monte Carlo integration
          const convergence =
            10 * (1 - Math.exp(-n / 10)) + Math.random() * 2 - 1;
          return Math.max(0, convergence);
        });

        const chartConfig = {
          type: "line",
          data: {
            labels: samples,
            datasets: [
              {
                label: "Convergência da Iluminação (Monte Carlo)",
                data: lightIntensity,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.2)",
                tension: 0.3,
                pointRadius: 2,
                pointBackgroundColor: "#00ff41",
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                title: {
                  display: true,
                  text: "Intensidade da Luz",
                  color: "#00ff41",
                },
                beginAtZero: true,
                grid: { color: "rgba(0, 255, 65, 0.1)" },
                ticks: { color: "#00ff41" },
              },
              x: {
                title: {
                  display: true,
                  text: "Número de Amostras Ray Tracing",
                  color: "#00ff41",
                },
                grid: { color: "rgba(0, 255, 65, 0.1)" },
                ticks: { color: "#00ff41" },
              },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
          },
        };

        activeCharts["graphics"] = new Chart(ctx, chartConfig);
      }

      function createProbabilityChart() {
        const ctx = document
          .getElementById("probability-chart")
          .getContext("2d");

        // Normal distribution data
        const x = Array.from({ length: 100 }, (_, i) => (i - 50) / 10);
        const mean = 0;
        const stdDev = 1;
        const pdf = x.map((val) => {
          const exponent = -0.5 * Math.pow((val - mean) / stdDev, 2);
          return (1 / (stdDev * Math.sqrt(2 * Math.PI))) * Math.exp(exponent);
        });

        const chartConfig = {
          type: "line",
          data: {
            labels: x.map((val) => val.toFixed(1)),
            datasets: [
              {
                label: "Função de Densidade de Probabilidade (PDF)",
                data: pdf,
                borderColor: "#00ff41",
                backgroundColor: "rgba(0, 255, 65, 0.3)",
                fill: true,
                tension: 0.4,
                pointRadius: 0,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                title: {
                  display: true,
                  text: "Densidade de Probabilidade",
                  color: "#00ff41",
                },
                beginAtZero: true,
                grid: { color: "rgba(0, 255, 65, 0.1)" },
                ticks: { color: "#00ff41" },
              },
              x: {
                title: {
                  display: true,
                  text: "Valor da Variável Aleatória",
                  color: "#00ff41",
                },
                grid: { color: "rgba(0, 255, 65, 0.1)" },
                ticks: { color: "#00ff41" },
              },
            },
            plugins: {
              legend: {
                position: "top",
                labels: {
                  color: "#00ff41",
                },
              },
            },
          },
        };

        activeCharts["probability"] = new Chart(ctx, chartConfig);
      }
    </script>
  </body>
</html>
